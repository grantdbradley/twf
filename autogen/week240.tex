
% </A>
% </A>
% </A>
\week{October 22, 2006 }


I'm back from Shanghai, and classes are well underway now.  For the
last few weeks I'd been frantically preparing a talk for Stewart
Brand's "Seminars About Long-Term Thinking", up in San
Francisco.  I talked about how we need to "zoom out" of our
short-term perspective to understand the history of the earth's
climate and what we're doing to it now:

1) John Baez, Zooming out in time, 
<a href = "http://math.ucr.edu/home/baez/zoom/">http://math.ucr.edu/home/baez/zoom/</a>

There's a lot of tricky physics in this business.  Consider, 
for example, this graph of cycles governing the Earth's precession, 
the obliquity of its orbit, and the eccentricity of its orbit:

<div align = center>
<img src = "Milankovitch_Variations.png">
</div>

2) Wikipedia, Milankovitch cycles, 
<a href = "http://en.wikipedia.org/wiki/Milankovitch_cycles">http://en.wikipedia.org/wiki/Milankovitch_cycles</a>

Here a "kyr" is a thousand years.  
The yellow curve combines information from all three of these cycles
and shows the amount of solar radiation at 65 degrees north latitude.
The bottom black curve shows the amount of glaciation.  As
Milankovitch's theory predicts, you can sort of see a correlation
between the yellow and black curves - but it's nothing simple or
obvious.  One reason is the complex feedback mechanisms within the
Earth's climate.

Here's a great place to read about this stuff:

3) Barry Saltzman, Dynamical Paleoclimatology: Generalized Theory of 
Global Climate Change, Academic Press, New York, 2002.

Anyway, now this talk is done, and I can focus more on teaching.

In my seminar this year, we're focusing on two topics: quantization
and cohomology, and classical versus quantum computation.  I'm
trying out something new: not only are the notes available on the 
web, there's also a blog entry for each class, where you can ask 
questions, make comments and correct my mistakes!

4) John Baez, Fall 2006 seminars: Quantization and cohomology, and
Classical versus quantum computation.  Notes by Derek Wise, homeworks
and blog entries available at
<a href = "http://math.ucr.edu/home/baez/qg-fall2006/">http://math.ucr.edu/home/baez/qg-fall2006/</a>

I hope more people blend teaching with blogging.  It's not too much work 
if someone with legible handwriting takes notes and the lectures can 
actually be followed from the notes.  You can use blogging to 
interactively teach people scattered all over the planet!

This week, James Dolan gave a talk on something he's been working on for 
a long time: games and cartesian closed categories.  Lately he's been 
working with Todd Trimble, and they reproved some important results in
a fun new way.  Let me sketch the ideas for you....

Let's play a game.  I have a set X in my pocket, and I'm not telling 
you what it is.  Can you pick an element of X in a systematic way?  

No, of course not: you don't have enough information.  X could even 
be empty, in which case you're clearly doomed!  But even if it's nonempty, 
if you don't know anything about it, you can't pick an element in a 
systematic way.  

So, you lose.

Okay, let's play another game.  Can you pick an element of 

X^{X} 

in a systematic way?  Here A^{B} means the set of functions
from B to A.  So, I'm asking if you can pick a function from X to
itself in a systematic way.

Yes!  You can pick the identity function!  This sends each element
of X to itself:

x |\to  x

You don't need to know anything about X to describe this function. 
X can even be empty.  

So, you win.  

Are there any other ways to win?  No.  

Now let's play another game.  Can you pick an element of 

X^{( X<sup>X} )</sup>

in a systematic way?  

An element in here takes functions from X to itself and turns them into 
elements of X.  When X is the set of real numbers, people call this sort 
of thing a "functional", so let's use that term.  A functional eats 
functions and spits out elements.

You can scratch your head for a while trying to dream up a systematic
way to pick a functional for any set X.  But, there's no way. 

So, you lose.

Let's play another game.  Can you pick an element of 

(X^{X})^{( X<sup>X} )</sup>

in a systematic way?  

An element in here eats functions and spits out functions.  When X is
the set of real numbers, people often call this sort of thing an 
"operator", so let's use that term.  

Given an unknown set X, can you pick an operator in a systematic
way?  Sure!  You can pick the identity operator.  This operator 
eats any function from X to itself and spits out the same function:

f |\to  f

Anyway: you win.

Are there any other ways to win?  Yes!  There's an operator that
takes any function and spits out the identity function:

f |\to  (x |\to  x)

This is a bit funny-looking, but I hope you get what it means: you
put in any function f, and out pops the identity function x |\to  x.

This arrow notation is very powerful.  It's usually called the 
"\lambda  calculus", since when Church invented it in the 1930s, he 
wrote it using the Greek letter \lambda  instead of an arrow: instead of 

x |\to  y

he wrote

\lambda  x.y

But this just makes things more confusing, so let's not do it.

Are there more ways to win this game?  Yes!  There's also an operator
called "squaring", which takes any function f from X to itself 
and "squares" it - in other words, does it twice.  If we write
the result as f^{2}, this operator is

f |\to  f^{2}

But, we can express this operator without using any special symbol
for squaring.  The function f is the same as the function

x |\to  f(x)

so the function f^{2} is the same as

x |\to  f(f(x))

and the operator "squaring" is the same as

f |\to  (x |\to  f(f(x)))

This looks pretty complicated.  But, it shows that our systematic
way of choosing an element of 

(X^{X})^{( X<sup>X} )</sup>

can still be expressed using just the \lambda  calculus.

Now that you know "squaring" is a way to win this particular game, 
you'll immediately guess a bunch of other ways: "cubing", and so on.  
It turns out all the winning strategies are of this form!  We can 
list them all using the \lambda  calculus:

f |\to  (x |\to  x)

f |\to  (x |\to  f(x))

f |\to  (x |\to  f(f(x)))

f |\to  (x |\to  f(f(f(x))))

etc.  Note that the second one is just a longer name for the 
identity operator.  The longer name makes the pattern clear.

So far, all these methods of picking an element of 
(X^{X})^{( X<sup>X} )</sup> for an unknown set X can be 
written using the \lambda  calculus.   There are other sneakier ways.  For 
example, there's the operator that sends functions with fixed 
points to the identity function, and sends functions without fixed 
points to themselves.  It's an interesting challenge to figure out all
these sneaky ways, but it's way too hard for me.   So, from now on, 
just to keep things simple, let's only consider "systematic ways"
that can be expressed using the \lambda  calculus.  To win one of my games,
you need to use the \lambda  calculus to pick an element of the set I write
down.

So, let's play another game.  Can you write down an element of

X ^{( X<sup>( X<sup>X} )</sup> )</sup>

using the \lambda  calculus?

An element in here eats functionals and spits out elements of X.  
So, it's called a "functionalal" on X.  At least that's what Jim
calls it.

If I have an unknown set in my pocket, can you write down functionalal 
on this set using the \lambda  calculus?

Yes!  You need to dream up a recipe that takes functionals on X
and turns them into elements of X.   Here's one recipe: take any 
functional and evaluate it on the \emph{identity} function, getting
an element of x.  

In \lambda  calculus notation, this recipe looks like this:

f |\to  f(x |\to  x)

Can you think of other ways to win this game?  I hope so: there are 
infinitely many!  Jim and Todd figured out a systematic way to list
them all.

Now let's play another game.  Can you write down an element of 

X^{(X<sup>(X<sup>(X<sup>X})</sup>)</sup>)</sup>

using the \lambda  calculus?  The parentheses are getting a little obnoxious
by now, so let's adopt the convention that A^{B<sup>C}</sup>
is short for A^{(B<sup>C})</sup>, which lets us write the
above expression as

X^{X<sup>X<sup>X<sup>X}</sup></sup></sup>

A thing in here eats functionalals and spits out
elements of X, so it's called a "functionalalal".  

So, can you write down a functionalalal on an unknown set using the
\lambda  calculus?

The answer is no: you lose.  

How about writing down an element of



% parser failed at source line 352
